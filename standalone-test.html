<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‹¬ç«‹æµ‹è¯• - HookRegForge</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px; 
            background: #1a1a1a; 
            color: #fff; 
        }
        .section { 
            margin: 20px 0; 
            padding: 15px; 
            border: 1px solid #444; 
            background: #2a2a2a;
            border-radius: 8px;
        }
        .btn { 
            padding: 10px 20px; 
            margin: 5px; 
            cursor: pointer; 
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }
        .btn:hover { background: #2563eb; }
        .btn:active { 
            background: #1d4ed8; 
            transform: translateY(1px);
        }
        .file-upload-btn {
            position: relative;
            overflow: hidden;
        }
        .file-upload-btn input[type="file"] {
            position: absolute;
            left: -9999px;
            opacity: 0;
        }
        textarea, input, select {
            width: calc(100% - 20px);
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #444;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .output {
            background: #333;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            min-height: 100px;
            border: 1px solid #555;
        }
        .message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            font-size: 14px;
            max-width: 300px;
            animation: slideIn 0.3s ease-out;
        }
        .message.success { background: #10b981; color: white; }
        .message.error { background: #ef4444; color: white; }
        .message.info { background: #3b82f6; color: white; }
        .message.warning { background: #f59e0b; color: white; }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .path-item {
            background: #2a2a2a;
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid #3b82f6;
            border-radius: 4px;
        }
        
        .path-name {
            font-weight: bold;
            color: #60a5fa;
        }
        
        .path-details {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>ğŸ§ª HookRegForge ç‹¬ç«‹åŠŸèƒ½æµ‹è¯•</h1>
    
    <div class="section">
        <h2>ğŸ® æ“ä½œæŒ‰é’®</h2>
        <button data-action="clear" class="btn">æ¸…ç©º</button>
        <button data-action="load-sample" class="btn">åŠ è½½ç¤ºä¾‹</button>
        <button data-action="generate" class="btn">ç”ŸæˆHookæ­£åˆ™</button>
        <button data-action="copy-regex" class="btn">å¤åˆ¶æ­£åˆ™</button>
        <button data-action="test" class="btn">æµ‹è¯•æ­£åˆ™</button>
        <label data-action="upload-file" class="btn file-upload-btn">
            ä¸Šä¼ æ–‡ä»¶
            <input type="file" data-field="file-input" accept=".js,.txt,.json">
        </label>
    </div>
    
    <div class="section">
        <h2>ğŸ“ è¾“å…¥é…ç½®</h2>
        <textarea data-field="js-input" rows="12" placeholder="åœ¨æ­¤è¾“å…¥JavaScriptä»£ç ..."></textarea>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
            <input data-field="target-function" placeholder="ç›®æ ‡å‡½æ•°å (å¯é€‰)">
            <select data-field="hook-type">
                <option value="function">å‡½æ•°è°ƒç”¨</option>
                <option value="property">å±æ€§è®¿é—®</option>
                <option value="method">æ–¹æ³•è°ƒç”¨</option>
                <option value="all">å…¨éƒ¨è·¯å¾„</option>
            </select>
            <input data-field="depth" type="number" min="1" max="10" value="3" placeholder="æœç´¢æ·±åº¦">
        </div>
        
        <label style="display: block; margin: 10px 0;">
            <input data-field="flexible" type="checkbox"> å¼¹æ€§åŒ¹é…æ¨¡å¼
        </label>
    </div>
    
    <div class="section">
        <h2>ğŸ“Š åˆ†æç»“æœ</h2>
        
        <h3>AST ç»“æ„</h3>
        <div data-output="ast" class="output">è§£æçš„ASTç»“æ„å°†åœ¨è¿™é‡Œæ˜¾ç¤º...</div>
        
        <h3>å‡½æ•°è·¯å¾„ (<span data-counter="paths">0 ä¸ªè·¯å¾„</span>)</h3>
        <div data-list="paths" class="output">è¾“å…¥ä»£ç å¹¶ç‚¹å‡»"ç”ŸæˆHookæ­£åˆ™"æ¥å‘ç°å‡½æ•°è·¯å¾„</div>
        
        <h3>æ­£åˆ™è¡¨è¾¾å¼</h3>
        <div data-output="regex" class="output">ç”Ÿæˆçš„æ­£åˆ™è¡¨è¾¾å¼å°†åœ¨è¿™é‡Œæ˜¾ç¤º...</div>
        <div data-output="regex-explanation" class="output">æ­£åˆ™è¡¨è¾¾å¼çš„è¯¦ç»†è§£é‡Šå°†åœ¨è¿™é‡Œæ˜¾ç¤º...</div>
    </div>
    
    <div class="section">
        <h2>ğŸ§ª æµ‹è¯•éªŒè¯</h2>
        <textarea data-field="test-string" rows="3" placeholder="è¾“å…¥æµ‹è¯•å­—ç¬¦ä¸²..."></textarea>
        <div data-output="test" class="output">æµ‹è¯•ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/esprima/4.0.1/esprima.min.js"></script>
    <script>
        // åº”ç”¨çŠ¶æ€
        const appState = {
            ast: null,
            paths: [],
            regex: '',
            config: {
                targetFunction: '',
                hookType: 'function',
                depth: 3,
                flexible: false
            }
        };
        
        // ç¤ºä¾‹ä»£ç 
        const sampleCode = `// å¤æ‚çš„JavaScriptå¯¹è±¡ç»“æ„
var MyApp = {
    user: {
        profile: {
            getName: function() {
                return this.name;
            },
            setName: function(name) {
                this.name = name;
            }
        }
    },
    utils: {
        crypto: {
            encrypt: function(data) {
                return btoa(JSON.stringify(data));
            }
        }
    }
};

// å‡½æ•°è°ƒç”¨ç¤ºä¾‹
function processUserData(userData) {
    const name = MyApp.user.profile.getName();
    const encrypted = MyApp.utils.crypto.encrypt(userData);
    return { name, data: encrypted };
}

// åŠ¨æ€å±æ€§è®¿é—®
window['MyApp']['user']['profile']['getName']();`;

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(text, type = 'info') {
            console.log(`[${type.toUpperCase()}] ${text}`);
            
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            document.body.appendChild(message);
            
            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 3000);
        }
        
        // HTMLè½¬ä¹‰
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // è·å–é…ç½®
        function getConfig() {
            return {
                targetFunction: document.querySelector('[data-field="target-function"]').value || '',
                hookType: document.querySelector('[data-field="hook-type"]').value || 'function',
                depth: parseInt(document.querySelector('[data-field="depth"]').value || '3'),
                flexible: document.querySelector('[data-field="flexible"]').checked || false
            };
        }
        
        // ç®€åŒ–çš„ASTè·¯å¾„æå–
        function extractPaths(ast, config) {
            const paths = [];
            
            function traverse(node, currentPath = []) {
                if (!node || typeof node !== 'object') return;
                
                // æå–æˆå‘˜è¡¨è¾¾å¼ (obj.prop, obj['prop'])
                if (node.type === 'MemberExpression') {
                    const path = buildPath(node);
                    if (path) {
                        paths.push({
                            path: path,
                            type: 'property',
                            context: 'member_access',
                            computed: node.computed
                        });
                    }
                }
                
                // æå–å‡½æ•°è°ƒç”¨ (func(), obj.method())
                if (node.type === 'CallExpression') {
                    if (node.callee.type === 'MemberExpression') {
                        const path = buildPath(node.callee);
                        if (path) {
                            paths.push({
                                path: path,
                                type: 'method',
                                context: 'function_call',
                                arguments: node.arguments.length
                            });
                        }
                    } else if (node.callee.type === 'Identifier') {
                        paths.push({
                            path: node.callee.name,
                            type: 'function',
                            context: 'function_call',
                            arguments: node.arguments.length
                        });
                    }
                }
                
                // é€’å½’éå†
                for (const key in node) {
                    if (key !== 'parent' && key !== 'range' && key !== 'loc') {
                        const child = node[key];
                        if (Array.isArray(child)) {
                            child.forEach(item => traverse(item, currentPath));
                        } else if (child && typeof child === 'object') {
                            traverse(child, currentPath);
                        }
                    }
                }
            }
            
            function buildPath(memberExpr) {
                const parts = [];
                let current = memberExpr;
                
                while (current) {
                    if (current.type === 'MemberExpression') {
                        if (current.property) {
                            if (current.computed) {
                                if (current.property.type === 'Literal') {
                                    parts.unshift(`["${current.property.value}"]`);
                                } else {
                                    parts.unshift(`[${current.property.name || 'unknown'}]`);
                                }
                            } else {
                                parts.unshift(`.${current.property.name}`);
                            }
                        }
                        current = current.object;
                    } else if (current.type === 'Identifier') {
                        parts.unshift(current.name);
                        break;
                    } else {
                        parts.unshift('unknown');
                        break;
                    }
                }
                
                return parts.join('').replace(/^\./, '');
            }
            
            traverse(ast);
            
            // è¿‡æ»¤è·¯å¾„
            let filteredPaths = paths;
            
            if (config.targetFunction) {
                filteredPaths = paths.filter(path => 
                    path.path.includes(config.targetFunction)
                );
            }
            
            if (config.hookType !== 'all') {
                filteredPaths = filteredPaths.filter(path => 
                    path.type === config.hookType
                );
            }
            
            return filteredPaths;
        }
        
        // ç”Ÿæˆæ­£åˆ™è¡¨è¾¾å¼
        function generateRegex(paths, config) {
            if (paths.length === 0) {
                return {
                    regex: '',
                    explanation: 'æ²¡æœ‰æ‰¾åˆ°å¯ç”Ÿæˆæ­£åˆ™çš„è·¯å¾„'
                };
            }
            
            const patterns = paths.map(path => {
                let pattern = path.path.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                
                if (config.flexible) {
                    // å¼¹æ€§åŒ¹é…ï¼šæ”¯æŒä¸åŒçš„è®¿é—®æ–¹å¼
                    pattern = pattern
                        .replace(/\\\./g, '(?:\\.|\\[\\s*["\']?)') // . æˆ– ["
                        .replace(/\\\[/g, '(?:\\[\\s*["\']?)') // [
                        .replace(/\\\]/g, '(?:["\']?\\s*\\])'); // ]
                }
                
                return pattern;
            });
            
            const uniquePatterns = [...new Set(patterns)];
            const combinedPattern = uniquePatterns.length === 1 ? 
                uniquePatterns[0] : 
                `(${uniquePatterns.join('|')})`;
            
            return {
                regex: combinedPattern,
                explanation: `ç”Ÿæˆäº† ${uniquePatterns.length} ä¸ªæ¨¡å¼ï¼ŒåŒ¹é… ${paths.length} ä¸ªè·¯å¾„`
            };
        }
        
        // æµ‹è¯•æ­£åˆ™è¡¨è¾¾å¼
        function testRegex(regex, testString) {
            try {
                const regexObj = new RegExp(regex, 'g');
                const matches = [];
                let match;
                
                while ((match = regexObj.exec(testString)) !== null) {
                    matches.push({
                        text: match[0],
                        position: match.index,
                        length: match[0].length
                    });
                    
                    if (!regexObj.global) break;
                }
                
                return {
                    success: true,
                    matches: matches
                };
            } catch (error) {
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        // äº‹ä»¶å¤„ç†å‡½æ•°
        const handlers = {
            clear: function() {
                console.log('ğŸ¯ æ¸…ç©ºæŒ‰é’®è¢«ç‚¹å‡»');
                document.querySelector('[data-field="js-input"]').value = '';
                document.querySelector('[data-output="ast"]').innerHTML = 'è§£æçš„ASTç»“æ„å°†åœ¨è¿™é‡Œæ˜¾ç¤º...';
                document.querySelector('[data-list="paths"]').innerHTML = 'è¾“å…¥ä»£ç å¹¶ç‚¹å‡»"ç”ŸæˆHookæ­£åˆ™"æ¥å‘ç°å‡½æ•°è·¯å¾„';
                document.querySelector('[data-output="regex"]').innerHTML = 'ç”Ÿæˆçš„æ­£åˆ™è¡¨è¾¾å¼å°†åœ¨è¿™é‡Œæ˜¾ç¤º...';
                document.querySelector('[data-counter="paths"]').textContent = '0 ä¸ªè·¯å¾„';
                appState.ast = null;
                appState.paths = [];
                appState.regex = '';
                showMessage('è¾“å…¥å·²æ¸…ç©º', 'success');
            },
            
            'load-sample': function() {
                console.log('ğŸ¯ åŠ è½½ç¤ºä¾‹æŒ‰é’®è¢«ç‚¹å‡»');
                document.querySelector('[data-field="js-input"]').value = sampleCode;
                document.querySelector('[data-field="target-function"]').value = 'getName';
                showMessage('ç¤ºä¾‹ä»£ç å·²åŠ è½½', 'success');
            },
            
            generate: function() {
                console.log('ğŸ¯ ç”ŸæˆæŒ‰é’®è¢«ç‚¹å‡»');
                const code = document.querySelector('[data-field="js-input"]').value.trim();
                
                if (!code) {
                    showMessage('è¯·è¾“å…¥JavaScriptä»£ç ', 'error');
                    return;
                }
                
                showMessage('æ­£åœ¨ç”ŸæˆHookæ­£åˆ™...', 'info');
                
                try {
                    // è§£æAST
                    appState.ast = esprima.parseScript(code);
                    document.querySelector('[data-output="ast"]').innerHTML = 
                        `<pre>${escapeHtml(JSON.stringify(appState.ast, null, 2).substring(0, 2000))}...</pre>`;
                    
                    // æå–è·¯å¾„
                    appState.config = getConfig();
                    appState.paths = extractPaths(appState.ast, appState.config);
                    
                    // æ˜¾ç¤ºè·¯å¾„
                    document.querySelector('[data-counter="paths"]').textContent = `${appState.paths.length} ä¸ªè·¯å¾„`;
                    
                    if (appState.paths.length === 0) {
                        document.querySelector('[data-list="paths"]').innerHTML = 'æœªæ‰¾åˆ°åŒ¹é…çš„å‡½æ•°è·¯å¾„';
                    } else {
                        const pathsHtml = appState.paths.map(path => `
                            <div class="path-item">
                                <div class="path-name">${escapeHtml(path.path)}</div>
                                <div class="path-details">
                                    ç±»å‹: ${path.type} â€¢ ä¸Šä¸‹æ–‡: ${path.context}
                                    ${path.arguments !== undefined ? ` â€¢ å‚æ•°: ${path.arguments}` : ''}
                                    ${path.computed ? ' â€¢ è®¡ç®—å±æ€§' : ''}
                                </div>
                            </div>
                        `).join('');
                        document.querySelector('[data-list="paths"]').innerHTML = pathsHtml;
                    }
                    
                    // ç”Ÿæˆæ­£åˆ™
                    const regexResult = generateRegex(appState.paths, appState.config);
                    appState.regex = regexResult.regex;
                    
                    document.querySelector('[data-output="regex"]').innerHTML = 
                        `<code>${escapeHtml(regexResult.regex)}</code>`;
                    document.querySelector('[data-output="regex-explanation"]').innerHTML = 
                        regexResult.explanation;
                    
                    showMessage('Hookæ­£åˆ™ç”Ÿæˆå®Œæˆ', 'success');
                    
                } catch (error) {
                    console.error('ç”Ÿæˆå¤±è´¥:', error);
                    showMessage(`ä»£ç è§£æå¤±è´¥: ${error.message}`, 'error');
                }
            },
            
            'copy-regex': function() {
                console.log('ğŸ¯ å¤åˆ¶æ­£åˆ™æŒ‰é’®è¢«ç‚¹å‡»');
                if (!appState.regex) {
                    showMessage('æ²¡æœ‰å¯å¤åˆ¶çš„æ­£åˆ™è¡¨è¾¾å¼', 'error');
                    return;
                }
                
                navigator.clipboard.writeText(appState.regex).then(() => {
                    showMessage('æ­£åˆ™è¡¨è¾¾å¼å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                }).catch(() => {
                    showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
                });
            },
            
            test: function() {
                console.log('ğŸ¯ æµ‹è¯•æŒ‰é’®è¢«ç‚¹å‡»');
                if (!appState.regex) {
                    showMessage('æ²¡æœ‰å¯æµ‹è¯•çš„æ­£åˆ™è¡¨è¾¾å¼', 'error');
                    return;
                }
                
                const testString = document.querySelector('[data-field="test-string"]').value.trim();
                if (!testString) {
                    showMessage('è¯·è¾“å…¥æµ‹è¯•å­—ç¬¦ä¸²', 'error');
                    return;
                }
                
                const result = testRegex(appState.regex, testString);
                
                if (!result.success) {
                    document.querySelector('[data-output="test"]').innerHTML = 
                        `<div style="color: #f87171;">é”™è¯¯: ${escapeHtml(result.error)}</div>`;
                    showMessage('æ­£åˆ™è¡¨è¾¾å¼æµ‹è¯•å¤±è´¥', 'error');
                    return;
                }
                
                if (result.matches.length === 0) {
                    document.querySelector('[data-output="test"]').innerHTML = 
                        '<div style="color: #fbbf24;">æ²¡æœ‰æ‰¾åˆ°åŒ¹é…é¡¹</div>';
                    showMessage('æ²¡æœ‰æ‰¾åˆ°åŒ¹é…é¡¹', 'info');
                } else {
                    const matchesHtml = result.matches.map((match, index) => `
                        <div style="background: #2a2a2a; padding: 8px; margin: 4px 0; border-radius: 4px;">
                            <div style="color: #4ade80;">åŒ¹é… ${index + 1}: "${escapeHtml(match.text)}"</div>
                            <div style="color: #9ca3af; font-size: 11px;">ä½ç½®: ${match.position} - ${match.position + match.length - 1}</div>
                        </div>
                    `).join('');
                    
                    document.querySelector('[data-output="test"]').innerHTML = matchesHtml;
                    showMessage(`æ‰¾åˆ° ${result.matches.length} ä¸ªåŒ¹é…é¡¹`, 'success');
                }
            }
        };
        
        // æ–‡ä»¶ä¸Šä¼ å¤„ç†
        function handleFileUpload(file) {
            console.log('ğŸ¯ æ–‡ä»¶ä¸Šä¼ äº‹ä»¶è§¦å‘');
            if (!file) return;
            
            showMessage(`æ­£åœ¨è¯»å–æ–‡ä»¶: ${file.name}`, 'info');
            
            // æ£€æŸ¥æ–‡ä»¶å¤§å°
            if (file.size > 10 * 1024 * 1024) {
                showMessage('æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶ (æœ€å¤§10MB)', 'error');
                return;
            }
            
            // æ£€æŸ¥æ–‡ä»¶ç±»å‹
            const validExtensions = ['.js', '.txt', '.json'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
            
            if (!validExtensions.includes(fileExtension)) {
                showMessage('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ã€‚è¯·ä¸Šä¼  .js, .txt æˆ– .json æ–‡ä»¶', 'error');
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const content = e.target.result;
                document.querySelector('[data-field="js-input"]').value = content;
                showMessage(`æ–‡ä»¶ "${file.name}" ä¸Šä¼ æˆåŠŸ`, 'success');
            };
            
            reader.onerror = function() {
                showMessage('æ–‡ä»¶è¯»å–å¤±è´¥', 'error');
            };
            
            reader.readAsText(file, 'UTF-8');
        }
        
        // ç»‘å®šäº‹ä»¶
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸš€ é¡µé¢åŠ è½½å®Œæˆï¼Œç»‘å®šäº‹ä»¶...');
            
            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            document.addEventListener('click', function(e) {
                const action = e.target.getAttribute('data-action');
                if (action && handlers[action]) {
                    e.preventDefault();
                    e.stopPropagation();
                    handlers[action]();
                }
            });
            
            // ç»‘å®šæ–‡ä»¶ä¸Šä¼ äº‹ä»¶
            document.querySelector('[data-field="file-input"]').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    handleFileUpload(file);
                }
            });
            
            showMessage('åº”ç”¨åˆå§‹åŒ–å®Œæˆï¼Œæ‰€æœ‰åŠŸèƒ½å¯ç”¨', 'success');
            console.log('âœ… æ‰€æœ‰äº‹ä»¶ç»‘å®šå®Œæˆ');
        });
    </script>
</body>
</html>